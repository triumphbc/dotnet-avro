{"componentChunkName":"component---src-templates-dotnet-type-js","path":"/api/chr.avro.confluent.asyncschemaregistrydeserializer-1","result":{"data":{"dotnetType":{"base":"T:System.Object","kind":"class","interfaces":["T:Confluent.Kafka.IAsyncDeserializer{`0}","T:System.IDisposable"],"name":"AsyncSchemaRegistryDeserializer<T>","remarks":null,"summary":"An <see cref=\"T:Confluent.Kafka.IAsyncDeserializer`1\" /> that resolves Avro schemas on the fly. When\n            deserializing messages, this deserializer will attempt to derive a schema ID from the first\n            five bytes. (For more information, see the <a href=\"https://docs.confluent.io/current/schema-registry/docs/serializer-formatter.html#wire-format\">Confluent wire format documentation</a>.)\n            If a schema with that ID is not found in cache, it will attempt to pull down a matching\n            schema from the Schema Registry.","assembly":{"id":"A:Chr.Avro.Confluent"},"members":[{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.#ctor","kind":"constructor","name":"#ctor","overloads":[{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.#ctor(Confluent.SchemaRegistry.ISchemaRegistryClient,Chr.Avro.Serialization.IBinaryDeserializerBuilder,Chr.Avro.Representation.IJsonSchemaReader)","returns":null,"summary":"Creates a deserializer.","typeParameters":null},{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String}},Chr.Avro.Serialization.IBinaryDeserializerBuilder,Chr.Avro.Representation.IJsonSchemaReader)","returns":null,"summary":"Creates a deserializer.","typeParameters":null}]},{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.DeserializeAsync","kind":"method","name":"DeserializeAsync","overloads":[{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.DeserializeAsync(System.ReadOnlyMemory{System.Byte},System.Boolean,Confluent.Kafka.SerializationContext)","returns":{"summary":"To be added.","type":"T:System.Threading.Tasks.Task{`0}"},"summary":"Deserialize a message. (See <see cref=\"M:Confluent.Kafka.IAsyncDeserializer`1.DeserializeAsync(System.ReadOnlyMemory{System.Byte},System.Boolean,Confluent.Kafka.SerializationContext)\" />.)","typeParameters":null}]},{"id":"P:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.DeserializerBuilder","kind":"property","name":"DeserializerBuilder","overloads":[{"id":"P:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.DeserializerBuilder","returns":{"summary":null,"type":"T:Chr.Avro.Serialization.IBinaryDeserializerBuilder"},"summary":"The deserializer builder used to generate deserialization functions for C# types.","typeParameters":null}]},{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.Dispose","kind":"method","name":"Dispose","overloads":[{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.Dispose()","returns":{"summary":null,"type":"T:System.Void"},"summary":"Disposes the deserializer, freeing up any resources.","typeParameters":null},{"id":"M:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.Dispose(System.Boolean)","returns":{"summary":null,"type":"T:System.Void"},"summary":"Disposes the deserializer, freeing up any resources.","typeParameters":null}]},{"id":"P:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.RegistryClient","kind":"property","name":"RegistryClient","overloads":[{"id":"P:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.RegistryClient","returns":{"summary":null,"type":"T:Confluent.SchemaRegistry.ISchemaRegistryClient"},"summary":"The client used for Schema Registry operations.","typeParameters":null}]},{"id":"P:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.SchemaReader","kind":"property","name":"SchemaReader","overloads":[{"id":"P:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1.SchemaReader","returns":{"summary":null,"type":"T:Chr.Avro.Representation.IJsonSchemaReader"},"summary":"The JSON schema reader used to convert schemas received from the registry into abstract\n            representations.","typeParameters":null}]}],"namespace":{"id":"N:Chr.Avro.Confluent","name":"Chr.Avro.Confluent"},"typeParameters":[{"name":"T"}],"typeSignatures":[{"language":"C#","value":"public class AsyncSchemaRegistryDeserializer<T> : Confluent.Kafka.IAsyncDeserializer<T>, IDisposable"},{"language":"ILAsm","value":".class public auto ansi beforefieldinit AsyncSchemaRegistryDeserializer`1<T> extends System.Object implements class Confluent.Kafka.IAsyncDeserializer`1<!T>, class System.IDisposable"}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"T:Chr.Avro.Confluent.AsyncSchemaRegistryDeserializer`1"}}}